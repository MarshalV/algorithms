# Поиск наибольшей общей подпоследовательности (Longest Common Subsequence): Поиск длины наибольшей общей подпоследовательности двух строк.

"""
Поиск наибольшей общей подпоследовательности (Longest Common Subsequence, LCS) - это классическая задача динамического программирования, 
которая заключается в поиске наибольшей (максимальной) последовательности символов, 
которая является подпоследовательностью (не обязательно подстрокой) для двух или более заданных строк.

Подпоследовательностью называется любая последовательность символов, 
которая может быть получена путем удаления некоторых символов из исходной строки без изменения порядка оставшихся символов.

Например, для строк "ABCBDAB" и "BDCAB" одной из наибольших общих подпоследовательностей является "BCAB" (в данном случае общая подпоследовательность длиной 4). 
Обратите внимание, что символы в общей подпоследовательности не обязательно идут подряд в исходных строках.

Задача поиска наибольшей общей подпоследовательности имеет множество приложений,
включая обработку текста, биоинформатику, сравнение строк и редакцию текста."""

def lcs(X, Y):
    # Определяем функцию lcs с двумя аргументами X и Y (две строки, для которых мы ищем наибольшую общую подпоследовательность)
    m = len(X)
    n = len(Y)
    # Вычисляем длины строк X и Y
    L = [[0] * (n + 1) for i in range(m + 1)]
    # Создаем двумерный массив L размером (m+1) x (n+1), заполненный нулями
    for i in range(m + 1):
        for j in range(n + 1):
            # Проходим по всем элементам массива L
            if i == 0 or j == 0:
                # Если одна из строк имеет длину 0, то длина наибольшей общей подпоследовательности равна 0
                L[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                # Если символы в текущих позициях X и Y совпадают, увеличиваем на 1 длину наибольшей общей подпоследовательности,
                # взяв во внимание предыдущие символы
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                # Иначе выбираем максимальную длину наибольшей общей подпоследовательности из соседних ячеек массива L
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
                
    return L[m][n] # Возвращаем длину наибольшей общей подпоследовательности
    

    
# Вызываем функцию lcs с двумя строками для поиска наибольшей общей подпоследовательности
X = "ABCBDABYTNRVMX"
Y = "BDCABY"
result = lcs(X, Y)

# Выводим длину наибольшей общей подпоследовательности
print("Длина наибольшей общей подпоследовательности:", result)
