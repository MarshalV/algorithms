# Алгоритм нахождения кратчайшего пути в невзвешенном графе (Breadth-First Search)

"""Функция bfs реализует обход графа в ширину (breadth-first search, BFS), 
который исследует все вершины на одной глубине перед тем, как перейти к вершинам следующей глубины. 
Обход в ширину особенно полезен для нахождения кратчайших путей или проверки связности графа."""

from collections import deque
# Импортируем класс deque из модуля collections для использования очереди

def bfs(graph, start):
    # Определяем функцию bfs с аргументами graph (граф в виде словаря смежности) и start (начальная вершина обхода)
    visited = {vertex: False for vertex in graph}
    # Создаем словарь visited для отслеживания посещенных вершин, изначально все вершины помечаем как не посещенные
    visited[start] = True
    # Помечаем начальную вершину как посещенную
    queue = deque([start])
    # Создаем очередь, начиная с начальной вершины
    while queue:
        # Пока очередь не пуста
        current = queue.popleft()
        print("Visited:", current)
        # Извлекаем вершину из очереди
        for neighbor in graph[current]:
            # Перебираем соседей текущей вершины
            if not visited[neighbor]:
                # Если сосед еще не был посещен
                visited[neighbor] = True
                # Помечаем соседа как посещенного
                queue.append(neighbor)
                # Добавляем соседа в очередь для последующего посещения
                

# Пример графа в виде словаря смежности
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Вызываем функцию bfs для обхода графа в ширину, начиная с вершины 'A'
start_vertex = 'A'
bfs(graph, start_vertex)